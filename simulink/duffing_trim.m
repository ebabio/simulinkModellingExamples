%%  Initialization script for the Duffing continuous/discrete simulation

%% Setup workspace

clear
clc

%% Run init script

% define parameters for the duffing system and run an open loop sim
duffing_init;

%% Trim using Operating Point
% this method is contained in Simulink Control Design. It offers many more 
% features than the classical trim function such as:
% * working with reference modes
% * can have objective and constraint functions for trimming
% * can be used for remapping states
% see https://www.mathworks.com/help/slcontrol/ug/operspec.html

% operating point can be generated using the steady-state manager and exported here
% and then trimmed in batches for example.

% get an operating point from the current state
op0 = operspec(model);

% edit operating point
% it can be done graphically on 'Steady State Manager' Simulink App (SSM), 
% function code has been generated by SSM.
opspec = trim_constraints(op0);

% find operating point
opTrim = findop(model,opspec);

%% Simulate Mode from operating point

% set initial state to operating point:
% replicate the way it is done by the SSM updating the Model Configuration
% see Model Settings / Data Import/Export
op_string = 'opTrim';
set_param(model, 'LoadExternalInput', 'on')
set_param(model, 'ExternalInput', sprintf('getinputstruct(%s)', op_string) )
set_param(model, 'LoadInitialState', 'on')
set_param(model, 'InitialState', sprintf('getstatestruct(%s)', op_string) )

% simulate
simOut1 = sim(model);

% Plot trajectory in phase portrait
xSim1 = simOut1.yout{1}.Values.Data';
f1 = figure(1);
hold on
f1.NumberTitle = 'off';
plot(xSim1(1,:), xSim1(2,:))
f1Legend{2} = 'x1';
legend(f1Legend);

%% Low Level model handling
% the different methods of the model can be called for different purposes
% https://www.mathworks.com/help/simulink/slref/model_cmd.html

% get initial states in structure modes from operating point
for i=1:size(refMdls) % need to 
    set_param(refMdls{i},'SaveFormat','Structure');
end
u0_struct = getinputstruct(opTrim);
x0_struct = getstatestruct(opTrim);

% we can compile the system and access it programatically
[sizes, x0Alt, xStr] = feval(model, [],[],[],'compile');
y = feval(model, 0, x0_struct, u0_struct,'outputs'); % need to do it before calling anything else
xDot = feval(model, 0, x0_struct, u0_struct,'derivs'); % get the states derivatives
xNext = feval(model, 0, x0_struct, u0_struct,'update'); % get next state of discrte states
feval(model, [],[],[],'term');

% revert data format to dataset
for i=1:size(refMdls)
    set_param(refMdls{i},'SaveFormat','Dataset');
end

% A more human readable version of the states
% get info on the system on the sizes
% (it also allows for other call conventions!)
sldiagnostics(model,'Sizes');

%% Trim condition
% autogenerated from Steady State Manager

function opspec = trim_constraints(opspec)
% Set the constraints on the states in the model.
% - The defaults for all states are Known = false, SteadyState = true,
%   Min = -Inf, Max = Inf, dxMin = -Inf, and dxMax = Inf.

% State (1) - duffing/controller|controller/Delay
index = getStateIndex_SKD(opspec, 'duffing/controller|controller/adc');
% - Default model initial conditions are used to initialize optimization.

% duffing/duffingSystem/Integrator/xDotIntegrator
index = getStateIndex_SKD(opspec, 'xDot');
% - Default model initial conditions are used to initialize optimization.
opspec.States(index(1)).SteadyState = false;
opspec.States(index(1)).Min = 0.05;

% State (3) - duffing/duffingSystem/Integrator/xIntegrator
% - Default model initial conditions are used to initialize optimization.
index = getStateIndex_SKD(opspec, 'x');
opspec.States(index(1)).SteadyState = false;
opspec.States(index(1)).Min = 0.8;
end
